package lang

import (
	"strings"

	"github.com/benthosdev/benthos/v4/public/bloblang"
	"github.com/bxcodec/faker/v3"
	"github.com/gosimple/slug"
)

func init() {
	// Note: The examples are run and tested from within
	// ./internal/bloblang/query/parsed_test.go

	slugSpec := bloblang.NewPluginSpec().
		Experimental().
		Category("String Manipulation").
		Description(`Creates a "slug" from a given string. Wraps the github.com/gosimple/slug package. See its [docs](https://pkg.go.dev/github.com/gosimple/slug) for more information.`).
		Version("4.2.0").
		Example("Creates a slug from an English string",
			`root.slug = this.value.slug()`,
			[2]string{
				`{"value":"Gopher & Benthos"}`,
				`{"slug":"gopher-and-benthos"}`,
			}).
		Example("Creates a slug from a French string",
			`root.slug = this.value.slug("fr")`,
			[2]string{
				`{"value":"Gaufre & Poisson d'Eau Profonde"}`,
				`{"slug":"gaufre-et-poisson-deau-profonde"}`,
			}).Param(bloblang.NewStringParam("lang").Optional().Default("en"))

	if err := bloblang.RegisterMethodV2(
		"slug", slugSpec,
		func(args *bloblang.ParsedParams) (bloblang.Method, error) {
			langOpt, err := args.GetString("lang")
			if err != nil {
				return nil, err
			}
			return bloblang.StringMethod(func(s string) (interface{}, error) {
				return slug.MakeLang(s, langOpt), nil
			}), nil
		},
	); err != nil {
		panic(err)
	}

	fakerSpec := bloblang.NewPluginSpec().
		Experimental().
		Category("String Manipulation").
		Description("Uses the values in the structure to map to functions in the faker library. If value doesn't match a faker method, it remains unchanged.").
		Version("4.2.0").
		Example("Replaces any strings in 'this' that map to faker functions with generated strings",
			"root.result = this.fake()")

	if err := bloblang.RegisterMethodV2(
		"faker", fakerSpec,
		func(args *bloblang.ParsedParams) (bloblang.Method, error) {
			return bloblang.ObjectMethod(func(obj map[string]interface{}) (interface{}, error) {
				return populateFakeData(obj), nil
			}), nil
		},
	); err != nil {
		panic(err)
	}
}

func populateFakeData(data interface{}) interface{} {
	str, isString := data.(string)
	if isString {
		fakeValue := GetFakeValue(str)
		return fakeValue
	}

	array, isArray := data.([]interface{})
	if isArray {
		var newArray []interface{}
		for _, value := range array {
			newValue := populateFakeData(value)
			newArray = append(newArray, newValue)
		}
		return newArray
	}

	m, isMap := data.(map[string]interface{})
	if isMap {
		newMap := map[string]interface{}{}
		for key, value := range m {
			newValue := populateFakeData(value)
			newMap[key] = newValue
		}
		return newMap
	}

	return data
}

// GetFakeValue returns fake data generated by the faker function corresponding to the input string
func GetFakeValue(value string) string {
	result := value
	switch strings.ToLower(value) {
	case "email":
		result = faker.Email()
	case "date":
		result = faker.Date()
	}
	return result
}
